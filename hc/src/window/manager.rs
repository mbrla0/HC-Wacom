use stu::{Tablet, Queue, Capability};
use std::cell::RefCell;
use crate::path::{EventPath, EventCanvas};
use crate::window::area::PickPhysicalAreaError;
use crate::robot::Playback;
use std::time::Duration;
use std::num::NonZeroU32;
use crate::BitmapError;
use crate::window::AreaSelectionParameters;

/// Manage the given tablet device.
pub fn manage(device: Tablet) -> Result<(), ManagementError> {
	let queue = device.queue()
		.map_err(ManagementError::QueueCreationError)?;
	let caps = device.capability()
		.map_err(ManagementError::CapabilityQueryError)?;
	let (tx, rx) = std::sync::mpsc::channel();

	let window = ManagementWindow::new(
		device,
		queue,
		caps,
		tx);
	let _window = nwg::NativeUi::build_ui(window)
		.map_err(ManagementError::WindowCreationError)?;
	nwg::dispatch_thread_events();

	match rx.try_recv() {
		Ok(what) => Err(what),
		Err(_) => Ok(()),
	}
}

/// Tries running a device command and kills the manager if it fails.
macro_rules! mng_cmd_try {
	($this:expr, $e:expr) => {
		if let Err(what) = $e {
			$this.fail(ManagementError::DeviceCommandFailed(what));
			return
		}
	}
}

///
#[derive(nwd::NwgUi)]
pub struct ManagementWindow {
	/// The icon we're gonna be using for the window.
	#[nwg_resource(source_bin: Some(crate::window::ICON))]
	icon: nwg::Icon,

	/// The top level window this controller is contained in.
	#[nwg_control(
		title: "Tablet",
		flags: "WINDOW|MINIMIZE_BOX",
		center: true,
		icon: Some(&data.icon),
		size: (800, 600)
	)]
	#[nwg_events(
		OnInit: [Self::init],
		OnWindowClose: [Self::on_exit]
	)]
	window: nwg::Window,

	/// The controller managing the display of the pen bitmap.
	#[nwg_control(
		background_color: Some([255, 255, 255]),
		position: (10, 40)
	)]
	display: nwg::ImageFrame,

	/// Label for the device display.
	#[nwg_control(
		position: (10, 12),
		size: (100, 20)
	)]
	display_label: nwg::Label,

	/// Button for clearing the signature.
	#[nwg_control(
		position: (10, 150)
	)]
	#[nwg_events(
		OnButtonClick: [Self::on_clear_pressed]
	)]
	display_clear_btn: nwg::Button,

	/// Button for painting the signature.
	#[nwg_control(
		position: (110, 150)
	)]
	#[nwg_events(
		OnButtonClick: [Self::on_paint_pressed]
	)]
	display_paint_btn: nwg::Button,

	/// Button for accessing the help dialog box.
	#[nwg_control()]
	#[nwg_events(
		OnButtonClick: [Self::on_help_pressed]
	)]
	help_btn: nwg::Button,

	/// Button for accessing the bitmap upload functionality.
	#[nwg_control()]
	#[nwg_events(
		OnButtonClick: [Self::on_bitmap_load_pressed]
	)]
	bitmap_upload_btn: nwg::Button,

	/// The timer object whose job is to fire a callback for pulling in events
	/// from the tablet and updating user interface displays from tablet data.
	#[nwg_control(
		interval: std::time::Duration::new(0, 40_000_000),
		active: false,
		lifetime: None,
	)]
	#[nwg_events(
		OnTimerTick: [Self::on_update]
	)]
	update: nwg::AnimationTimer,

	/// Whether the management window is currently locked.
	locked: RefCell<bool>,

	/// The device we're connected to.
	device: Tablet,
	/// The queue though which we receive device updates.
	queue: RefCell<Queue>,

	/// The path accumulated from the events generated by the tablet.
	path: RefCell<EventPath>,
	/// The canvas accumulated from the events generated by the tablet.
	canvas: RefCell<EventCanvas>,

	/// The notification channel through which we know the painting is done.
	#[nwg_control()]
	#[nwg_events(
		OnNotice: [Self::on_paint_done]
	)]
	display_paint_done: nwg::Notice,

	/// The notification channel through which we know the bitmap window is done.
	#[nwg_control()]
	#[nwg_events(
		OnNotice: [Self::on_bitmap_window_done]
	)]
	bitmap_window_done: nwg::Notice,

	/// The channel through which we communicate failures.
	fails: std::sync::mpsc::Sender<ManagementError>,
}
impl ManagementWindow {
	fn new(
		device: Tablet,
		queue: Queue,
		caps: Capability,
		fails: std::sync::mpsc::Sender<ManagementError>) -> Self {

		Self {
			icon: Default::default(),
			window: Default::default(),
			display: Default::default(),
			display_label: Default::default(),
			display_clear_btn: Default::default(),
			display_paint_btn: Default::default(),
			help_btn: Default::default(),
			bitmap_upload_btn: Default::default(),
			update: Default::default(),
			locked: RefCell::new(false),
			device,
			queue: RefCell::new(queue),
			path: Default::default(),
			canvas: RefCell::new(EventCanvas::new(caps.width(), caps.height())),
			display_paint_done: Default::default(),
			bitmap_window_done: Default::default(),
			fails
		}
	}

	/// Locks all of the controls in this window.
	fn lock(&self) {
		mng_cmd_try!(self, self.device.inking(false));
		self.display_clear_btn.set_enabled(false);
		self.display_paint_btn.set_enabled(false);
		*self.locked.borrow_mut() = true;
	}

	/// Unlocks all of the controls in this window.
	fn unlock(&self) {
		mng_cmd_try!(self, self.device.inking(true));
		self.display_clear_btn.set_enabled(true);
		self.display_paint_btn.set_enabled(true);
		*self.locked.borrow_mut() = false;
	}

	/// Sets all the necessary conditions to return with the given error.
	fn fail(&self, what: ManagementError) {
		let _ = self.fails.send(what);
		nwg::stop_thread_dispatch();
	}

	/// Populates the data in the window controls.
	fn init(&self) {
		mng_cmd_try!(self, self.device.clear());
		mng_cmd_try!(self, self.device.inking(true));

		self.window.set_text(&crate::strings::manager::title());
		self.help_btn.set_text(&crate::strings::manager::help_btn());
		self.bitmap_upload_btn.set_text(&crate::strings::manager::bitmap_upload_btn());
		self.display_paint_btn.set_text(&crate::strings::manager::display_paint_btn());
		self.display_clear_btn.set_text(&crate::strings::manager::display_clear_btn());
		self.display_label.set_text(&crate::strings::manager::display_label());

		self.update(true);
		self.update.start();

		self.window.set_visible(true);
		self.window.set_focus();
	}

	/// Called when an intent for clearing the device screen has been fired.
	fn on_clear_pressed(&self) {
		mng_cmd_try!(self, self.device.inking(false));

		self.canvas.borrow_mut().clear();
		self.path.borrow_mut().clear();

		mng_cmd_try!(self, self.device.clear());
		mng_cmd_try!(self, self.device.inking(true));

		self.update(true);
	}

	/// Called when an intent for opening the help dialog has been fired.
	fn on_help_pressed(&self) {
		nwg::modal_info_message(
			&self.window,
			crate::strings::manager::help_btn(),
			crate::strings::manager::help());
	}

	/// Called when an intent for loading a bitmap signature has been fired.
	fn on_bitmap_load_pressed(&self) {
		self.lock();
		let channel = self.bitmap_window_done.sender();

		std::thread::spawn(move || {
			match super::bitmap::run(Some(channel)) {
				Ok(_) => {},
				Err(BitmapError::Cancelled) => {
					channel.notice();
				},
				Err(what) => {
					nwg::error_message(
						&crate::strings::errors::title(),
						&*match what {
							BitmapError::Cancelled => unreachable!(),
							BitmapError::InvalidFile(what) => format!(
								"{}: {}",
								crate::strings::errors::invalid_file(),
								what),
							BitmapError::FileNotFound =>
								crate::strings::errors::file_not_found().to_string(),
							BitmapError::WindowCreationError(what) =>
								crate::strings::errors::window_creation(what)
						});
					channel.notice();
				}
			}
		});
	}

	/// Called when the bitmap window is done.
	fn on_bitmap_window_done(&self) {
		self.unlock();
	}

	/// Called when an intent for painting the device data has been fired.
	fn on_paint_pressed(&self) {
		self.lock();

		let path = self.path.borrow().clone();
		let sender = self.display_paint_done.sender();

		let canvas = self.canvas.borrow();
		let width = canvas.width();
		let height = canvas.height();

		std::thread::spawn(move || {
			let area = super::pick_physical_area(AreaSelectionParameters {
				preferred_dimensions: (width, height)
			});
			let area = match area {
				Ok(area) => area,
				Err(PickPhysicalAreaError::Cancelled) => {
					sender.notice();
					return
				},
				Err(what) => {
					nwg::error_message(
						&crate::strings::errors::title(),
						&crate::strings::errors::signature_paint_pick_area_failed(what));
					sender.notice();
					return
				}
			};

			Playback {
				path,
				target: area,
				delta: Duration::from_secs(8),
				steps: unsafe { NonZeroU32::new_unchecked(5000) }
			}.play_and_notify(sender);
		});
	}

	/// Called when the painting of the signature has been completed.
	fn on_paint_done(&self) {
		self.unlock();
	}

	/// Pulls in events from the device and repaints the screen.
	fn update(&self, force_repaint: bool) {
		/* Process the input events. */
		let mut queue = self.queue.borrow_mut();
		let mut canvas = self.canvas.borrow_mut();
		let mut path = self.path.borrow_mut();

		let mut dirty = false;
		let locked = self.locked.borrow();
		loop {
			match queue.try_recv() {
				Ok(event) => {
					if !*locked {
						canvas.process(event);
						path.process(event);

						dirty = true;
					}
				},
				Err(stu::TryRecvError::Empty) =>
				/* Done processing events for now. */
					break,
				Err(stu::TryRecvError::Failed(what)) => {
					/* The polling process has failed. */
					self.fail(ManagementError::DevicePollingFailed(what));
					return
				}
			}
		}

		/* Update the display after the changes made by the events. */
		if dirty || force_repaint {
			let blob = canvas.to_bitmap();
			let bitmap = nwg::Bitmap::from_bin(&blob[..]).unwrap();

			self.display.set_size(canvas.width(), canvas.height());
			self.display.set_bitmap(Some(&bitmap));

			/* Move the UI around. */
			self.window.set_size(canvas.width() + 20, canvas.height() + 85);
			let (_, btn_height) = self.display_clear_btn.size();
			let (_, lbl_height) = self.display_label.size();

			self.display_label.set_size(
				canvas.width().saturating_sub(80),
				lbl_height);
			self.help_btn.set_position(
				canvas.width().saturating_sub(90) as i32,
				7);
			self.display_clear_btn.set_size(
				(canvas.width() / 3).saturating_sub(5),
				btn_height);
			self.display_paint_btn.set_size(
				(canvas.width() / 3).saturating_sub(5),
				btn_height);
			self.display_paint_btn.set_position(
				(20 + (canvas.width() / 3).saturating_sub(5)) as i32,
				150);
			self.bitmap_upload_btn.set_position(
				(20 + (canvas.width() / 3 * 2).saturating_sub(5)) as i32,
				150);
		}
	}

	/// Called when an update to the pen display preview has been requested.
	fn on_update(&self) {
		self.update(false)
	}

	/// Called when the window has been told to close.
	fn on_exit(&self) {
		self.on_clear_pressed();
		nwg::stop_thread_dispatch();
	}
}

/// This structure enumerates the reasons for which creation of a management
/// window may fail.
#[derive(Debug, thiserror::Error)]
pub enum ManagementError {
	/// The management window could not be created.
	#[error("could not create management window: {0}")]
	WindowCreationError(nwg::NwgError),
	/// The management window could not create the queue required to access the
	/// events generated by the tablet device and, thus cannot perform its job.
	#[error("could not create queue: {0}")]
	QueueCreationError(stu::Error),
	/// The management window could not poll for the capabilities of the tablet
	/// device we would be managing and, thus cannot perform its job.
	#[error("could not query for device capabilities: {0}")]
	CapabilityQueryError(stu::Error),
	/// While trying to poll events off the tablet device, we encountered a
	/// fatal error and had to terminate the management structure.
	#[error("device polling failed: {0}")]
	DevicePollingFailed(stu::Error),
	/// While trying to send a command off to the tablet device, we encountered
	/// a fatal error and had to terminate the management structure.
	#[error("device command failed: {0}")]
	DeviceCommandFailed(stu::Error),
}

